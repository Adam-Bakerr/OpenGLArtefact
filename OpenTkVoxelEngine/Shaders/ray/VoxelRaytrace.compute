#version 430
//Define size of local workgroup
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, binding = 0) uniform image2D screenTexture;
layout(rgba32f, binding = 1) uniform image3D voxelTexture;
layout(rgba32f, binding = 2) uniform image2D blockTexture;

uniform sampler3D voxelTextureSampler;


uniform vec2 dimensions;
uniform int textureDims[5];
uniform float chunkSize;
uniform float time;

uniform vec3 cameraForward;
uniform vec3 cameraRight;
uniform vec3 cameraUp;
uniform vec3 ro;


uniform vec3 position;
uniform float voxelSize[5];

const float rayBias = 0.001;
uniform int mipLevel;

vec3 CalcRayDirection(vec2 uv){
 return normalize(uv.x * cameraRight + uv.y * cameraUp + 1.0 * cameraForward);
}

bool intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax , inout float tNear, inout float tFar) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    tNear = max(max(t1.x, t1.y), t1.z);
    tFar = min(min(t2.x, t2.y), t2.z);
    return tNear <= tFar;
};

bool SampleColorAtVoxel(ivec3 p, int mip, out vec4 color){
    color = texelFetch(voxelTextureSampler, p , mip);
    return color.xyz != vec3(0);
}

vec2 MaxOfThree(vec3 p){
    return vec2(max(p.x,p.z),p.y);
}

vec3 lightpos = vec3(50);


float TraceShadow(vec3 rayhitpoint, int currentMip){
    vec3 rd = normalize((vec3(sin(time) * 25.0,15,sin(time) * 25.0)) - rayhitpoint);
    vec3 deltaDist = abs(vec3(length(rd)) / rd);
    ivec3 CurrentVoxel = ivec3(floor(rayhitpoint + 0.0));
    ivec3 rayStep = ivec3(sign(rd));

    //Distance To Next Axis Crossing
	vec3 sideDist = (sign(rd) * (vec3(CurrentVoxel) - rayhitpoint) + (sign(rd) * 0.5) + 0.5) * deltaDist; 

    bvec3 mask = bvec3(sign(rd));
    vec4 color = vec4(1);


    //while current point is within the bounds
    while(
    min(CurrentVoxel,ivec3(textureDims[currentMip])) == max(CurrentVoxel,ivec3(0))
    && mask != bvec3(0)
    ) {
        //Itterate and move to the next voxel
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
	    CurrentVoxel += ivec3(mask) * rayStep;

        if(SampleColorAtVoxel(CurrentVoxel,currentMip, color)){
            return .1;
        }
    }
    return 1.0;
}

void main()
{ 
    int currentMipLevel = mipLevel;

	ivec2 id = ivec2(gl_GlobalInvocationID.xy);

    //clear the pixeel
    imageStore(screenTexture,id,vec4(0));

    //Calculate ray direction
    vec2 screenPos = (vec2(id) / vec2(dimensions)) * 2.0 - 1.0;
	vec3 cameraPlaneU = cameraRight;
	vec3 cameraPlaneV = cameraUp * vec2(dimensions).y / vec2(dimensions).x;
    vec3 rd = cameraForward + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;

    float near; // t at which we first enter the voxel bound
    float far;  // t at which we first exit the voxel bound
    vec3 minb = vec3(0);
    ivec3 maxb = ivec3(chunkSize);
   
    

    //Check if we intersect the area taken by the texture
    if(!intersectAABB(ro,rd,minb,maxb,near,far))return;


    //Clamp the ray doesnt get reversed
    near = max(near,0);

    vec3 pointOfEntry = (ro + rd * near) / float(voxelSize[currentMipLevel]);

	ivec3 rayStep = ivec3(sign(rd));

    //Removes Circular Artifacts caused by the floor function by biasing the ray into the intersection slightly
    pointOfEntry = min(pointOfEntry,(maxb / float(voxelSize[currentMipLevel])) - vec3(.001));
    pointOfEntry = max(pointOfEntry,(minb / float(voxelSize[currentMipLevel])) + vec3(.001));

    //Round To Voxel
    ivec3 CurrentVoxel = ivec3(floor(pointOfEntry + 0.0));
    
    vec3 deltaDist = abs(vec3(length(rd)) / rd);

    //Distance To Next Axis Crossing
	vec3 sideDist = (sign(rd) * (vec3(CurrentVoxel) - pointOfEntry) + (sign(rd) * 0.5) + 0.5) * deltaDist; 

    bvec3 mask = bvec3(sign(rd));
    vec4 color = vec4(1);


    //while current point is within the bounds
    while(
    min(CurrentVoxel,ivec3(textureDims[currentMipLevel])) == max(CurrentVoxel,ivec3(0))
    && mask != bvec3(0)
    ) {
        //Sample The color of a voxel at the voxel poition to determine if its solid
        //This will be changed to better acompany pallettes

        if(SampleColorAtVoxel(CurrentVoxel,currentMipLevel, color)){
            
            //Calc Shadows
            float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rd);
            vec3 point = (pointOfEntry + (d * (rd * .99))) ;
            
            imageStore(screenTexture,id,color * TraceShadow(point,currentMipLevel));
            return;
        }




        //Itterate and move to the next voxel
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
	    CurrentVoxel += ivec3(mask) * rayStep;
    }

}