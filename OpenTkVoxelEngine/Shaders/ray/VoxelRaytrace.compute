#version 430
//Define size of local workgroup
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, binding = 0) uniform image2D screenTexture;
layout(rgba32f, binding = 1) uniform image3D voxelTexture;
uniform sampler3D voxelTextureSampler;


uniform vec2 dimensions;
uniform int textureDims[5];
uniform float chunkSize;

uniform vec3 cameraForward;
uniform vec3 cameraRight;
uniform vec3 cameraUp;
uniform vec3 ro;


uniform vec3 position;
uniform float voxelSize[5];

const float rayBias = 0.001;
uniform int mipLevel;

vec3 CalcRayDirection(vec2 uv){
 return normalize(uv.x * cameraRight + uv.y * cameraUp + 1.0 * cameraForward);
}

bool intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax , inout float tNear, inout float tFar) {
    vec3 tMin = (boxMin - rayOrigin) / rayDir;
    vec3 tMax = (boxMax - rayOrigin) / rayDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    tNear = max(max(t1.x, t1.y), t1.z);
    tFar = min(min(t2.x, t2.y), t2.z);
    return tNear <= tFar;
};



bool SampleColorAtVoxel(ivec3 p, int mip, out vec4 color){
    color = texelFetch(voxelTextureSampler, p , mip);
    return color.xyz != vec3(0);
}

void main()
{ 
    int currentMipLevel = mipLevel;

	ivec2 id = ivec2(gl_GlobalInvocationID.xy);

    //clear the pixeel
    imageStore(screenTexture,id,vec4(0));

    //Calculate ray direction
    vec2 screenPos = (vec2(id) / vec2(dimensions)) * 2.0 - 1.0;
	vec3 cameraPlaneU = cameraRight;
	vec3 cameraPlaneV = cameraUp * vec2(dimensions).y / vec2(dimensions).x;
    vec3 rd = cameraForward + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;

    float near; // t at which we first enter the voxel bound
    float far;  // t at which we first exit the voxel bound
    vec3 minb = vec3(0);
    ivec3 maxb = ivec3(chunkSize);
   
    

    //Check if we intersect the area taken by the texture
    if(!intersectAABB(ro,rd,minb,maxb,near,far))return;


    //Clamp the ray doesnt get reversed
    near = max(near,0);

    vec3 pointOfEntry = (ro + rd * near) / float(voxelSize[currentMipLevel]);

	ivec3 rayStep = ivec3(sign(rd));

    //Removes Circular Artifacts caused by the floor function by biasing the ray into the intersection slightly
    pointOfEntry += rayStep * rd * 0.001;

    //Round To Voxel
    ivec3 CurrentVoxel = ivec3(floor(pointOfEntry + 0.0));
    
    vec3 deltaDist = abs(vec3(length(rd)) / rd);

    //Tmax
	vec3 sideDist = (sign(rd) * (vec3(CurrentVoxel) - pointOfEntry) + (sign(rd) * 0.5) + 0.5) * deltaDist; 

    bvec3 mask = bvec3(rayStep);
    vec4 color = vec4(1);

    //while current point is within the bounds
    while(
    min(CurrentVoxel,ivec3(textureDims[currentMipLevel])) == max(CurrentVoxel,ivec3(0))
    && mask != bvec3(0)
    ) {
        //Sample The color of a voxel at the voxel poition to determine if its solid
        //This will be changed to better acompany pallettes

        if(SampleColorAtVoxel(CurrentVoxel,currentMipLevel, color)){
            imageStore(screenTexture,id,color * (dot(vec3(.1,-1,.2),-vec3(mask)) * .8) + .2);
            return;
        }
       
        //Itterate and move to the next voxel
        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
        sideDist += vec3(mask) * deltaDist;
	    CurrentVoxel += ivec3(vec3(mask)) * rayStep;

    }

}