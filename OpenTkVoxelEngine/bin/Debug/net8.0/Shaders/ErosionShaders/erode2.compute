#version 430


//Define size of local workgroup
layout(local_size_x = 1024 ) in;

struct vertex{
	vec4 Pos;
	vec4 Color;
	vec4 Normal;
};

struct droplet{
	vec2 pos;
};

uniform ivec2 vertexCount;
uniform int borderSize;
uniform int brushLength;
uniform int particleCount;

uniform int maxLifetime;
uniform float inertia;
uniform float sedimentCapacityFactor;
uniform float minSedimentCapacity;
uniform float depositSpeed;
uniform float erodeSpeed;

uniform float evaporateSpeed;
uniform float gravity;
uniform float startSpeed;
uniform float startWater;


layout(std430, binding = 0) buffer HeightMap
{
    float map[];
};

layout(std430, binding = 1) buffer Particle
{
    vec2 Particles[];
};

layout(std430, binding = 2) buffer brushIndexBuffer
{
    int brushIndices[];
};

layout(std430, binding = 3) buffer brushWeightBuffer
{
    float brushWeights[];
};

layout(std430, binding = 4) buffer vertexBuffer
{
    vertex verticies[];
};

vec4 CalculateNormal(int index){
	vec3 normal = vec3(0);

	vec3 p1 = verticies[index].Pos.xyz;
	vec3 p2 = verticies[index + 1].Pos.xyz;
	vec3 p3 = verticies[index + vertexCount.x].Pos.xyz;

	vec3 e1 = p2 - p1;
	vec3 e2 = p3 - p1;
	
	normal = cross(e1,e2);

	normal = normalize(-normal);

    return vec4(normal,1);

}


// Returns vec3(gradientX, gradientY, height)
vec3 CalculateHeightAndGradient (float posx, float posy) {
    int coordX = int(floor(posx));
    int coordY = int(floor(posy));

    // Calculate droplet's offset inside the cell (0,0) = at NW node, (1,1) = at SE node
    float x = posx - coordX;
    float y = posy - coordY;

    // Calculate heights of the four nodes of the droplet's cell
    int nodeIndexNW = coordY * vertexCount.x + coordX;
    float heightNW = map[nodeIndexNW];
    float heightNE = map[nodeIndexNW + 1];
    float heightSW = map[nodeIndexNW + vertexCount.x];
    float heightSE = map[nodeIndexNW + vertexCount.x + 1];

    // Calculate droplet's direction of flow with bilinear interpolation of height difference along the edges
    float gradientX = (heightNE - heightNW) * (1 - y) + (heightSE - heightSW) * y;
    float gradientY = (heightSW - heightNW) * (1 - x) + (heightSE - heightNE) * x;

    // Calculate height with bilinear interpolation of the heights of the nodes of the cell
    float height = heightNW * (1 - x) * (1 - y) + heightNE * x * (1 - y) + heightSW * (1 - x) * y + heightSE * x * y;

    return vec3(gradientX,gradientY,height);
}


void Erode(int x, int y)
{
    int cellIndex = (y * vertexCount.x + x);
    map[cellIndex] -= .01;
}

void Deposit(int x, int y)
{
    int newindex = (y * vertexCount.x + x);
    map[newindex] += .01;
}

void main()
{ 
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);

    if(id.x >= particleCount){
        return;
    }

    vec2 pos = Particles[id.x];
    float posX = pos.x;
    float posY = pos.y;
    vec3 initialHeightAndGradient = CalculateHeightAndGradient (posX, posY);

    vec2 dir = vec2(0);
   
    float speed = startSpeed;
    float water = startWater;
    float sediment = 0;

    for (int lifetime = 0; lifetime < maxLifetime; lifetime ++) {
        int nodeX = int(floor(posX));
        int nodeY = int(floor(posY));
        int dropletIndex = nodeY * vertexCount.x + nodeX;
        // Calculate droplet's offset inside the cell (0,0) = at NW node, (1,1) = at SE node
        float cellOffsetX = posX - nodeX;
        float cellOffsetY = posY - nodeY;

        // Calculate droplet's height and direction of flow with bilinear interpolation of surrounding heights
        vec3 heightAndGradient = CalculateHeightAndGradient (posX, posY);

        // Update the droplet's direction and position (move position 1 unit regardless of speed)
        dir.x = (dir.x * inertia - heightAndGradient.x * (1 - inertia));
        dir.y = (dir.y * inertia - heightAndGradient.y * (1 - inertia));
        
        dir = normalize(dir);
        posX += dir.x;
        posY += dir.y;

        if ((dir.x == 0 && dir.y == 0) || posX < borderSize || posX > vertexCount.x - borderSize || posY < borderSize || posY > vertexCount.x - borderSize) {
            map[dropletIndex] += sediment * (1 - cellOffsetX) * (1 - cellOffsetY);
            map[dropletIndex + 1] += sediment * cellOffsetX * (1 - cellOffsetY);
            map[dropletIndex + vertexCount.x] += sediment * (1 - cellOffsetX) * cellOffsetY;
            map[dropletIndex + vertexCount.x + 1] += sediment * cellOffsetX * cellOffsetY;
            break;
        }

        float newHeight = CalculateHeightAndGradient (posX, posY).z;
        float deltaHeight = newHeight - heightAndGradient.z;

        float sedimentCapacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);
        
         if (sediment > sedimentCapacity || deltaHeight > 0) {
            float amountToDeposit = (deltaHeight > 0) ? min(deltaHeight, sediment) : (sediment - sedimentCapacity) * depositSpeed;
            sediment -= amountToDeposit;


            map[dropletIndex] += clamp(amountToDeposit * (1 - cellOffsetX) * (1 - cellOffsetY),0,1);
            map[dropletIndex + 1] += clamp(amountToDeposit * cellOffsetX * (1 - cellOffsetY),0,1);
            map[dropletIndex + vertexCount.x] += clamp(amountToDeposit * (1 - cellOffsetX) * cellOffsetY,0,1);
            map[dropletIndex + vertexCount.x + 1] += clamp(amountToDeposit * cellOffsetX * cellOffsetY,0,1);
        }
        else {
            // Erode a fraction of the droplet's current carry capacity.
            // Clamp the erosion to the change in height so that it doesn't dig a hole in the terrain behind the droplet
            float amountToErode = min ((sedimentCapacity - sediment) * erodeSpeed, -deltaHeight);
            
            for (int i = 0; i < brushLength; i ++) {
                int erodeIndex = dropletIndex + brushIndices[i];

                float weightedErodeAmount = amountToErode * brushWeights[i];
                float deltaSediment = (map[erodeIndex] < weightedErodeAmount) ? map[erodeIndex] : weightedErodeAmount;
                map[erodeIndex] -= clamp(deltaSediment,0,1);
                sediment += deltaSediment;
            }
        }

        // Update droplet's speed and water content
        speed = sqrt (max(0,speed * speed + deltaHeight * gravity));
        water *= (1 - evaporateSpeed);
    }
}