#version 430

struct vertex{
	vec4 Pos;
	vec4 Color;
	vec4 Normal;
};


//Define size of local workgroup
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D biomeTexture;
uniform ivec2 gridDimensions;

uniform int seed;
uniform int NumLayers;
uniform vec3 centre;
uniform float baseRoughness;
uniform float roughness;
uniform float persistence;
uniform float minValue;
uniform float strength;
uniform float scale;
uniform float minHeight;
uniform float maxHeight;



layout(std430, binding = 1) buffer Vertex
{
    vertex verticies[];
};

//0 = min 1 = max
layout(std430, binding = 2) buffer vertexInfo
{
    int minMax[];
};

uniform int minMaxPrecisionFactor;



//Noise function source https://www.shadertoy.com/view/3dSBRh
// Rotate a vec2
vec2 rotate(vec2 vec, float rot)
{
    float s = sin(rot), c = cos(rot);
    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);
}

// Hash13 Hash without Sine: https://www.shadertoy.com/view/4djSRW
float hash(vec2 p, float t)
{
    vec3 p3 = vec3(p, t);
    p3  = fract(p3*0.1031);
    p3 += dot(p3, p3.zyx+31.32);
    return fract((p3.x+p3.y)*p3.z);
}

float noise(vec2 p, float t)
{
    vec4 b = vec4(floor(p), ceil(p));
    vec2 f = smoothstep(0.0, 1.0, fract(p));
    return mix(mix(hash(b.xy, t), hash(b.zy, t), f.x), mix(hash(b.xw, t), hash(b.zw, t), f.x), f.y);
}

//https://gist.github.com/WSWhitehouse/df30b5d0ecfb66cf7f023fe5c9a04518
float Lerp(float from, float to, float rel)
{
    return ((1 - rel) * from) + (rel * to);
}

float InvLerp(float from, float to, float value)
{
    return (value - from) / (to - from);
}

float Remap(float orig_from, float orig_to, float target_from, float target_to, float value)
{
    float rel = InvLerp(orig_from, orig_to, value);
    return Lerp(target_from, target_to, rel);
}
   
   #define pi 3.141592653589793

// Fractal Brownian Motion Noise
float fbm(vec2 pos)
{
    float value = 0.0;
    float Scale = scale;
    float atten = 0.5;
    float t = 0.0;
    for(int i = 0; i < NumLayers; i++)
    {
        t += atten;
        value += noise(pos*Scale, float(i))*atten;
        Scale *= 2.0;
        atten *= persistence;
        pos = rotate(pos, 0.125*pi);
    }
    return value/t;
}

void main()
{ 
	
	ivec2 id = ivec2(gl_GlobalInvocationID.xy);
	int index = id.y * gridDimensions.x + id.x;
	
	if(id.x >= gridDimensions.x || id.y >= gridDimensions.y ){
		return;
	}

	vec4 Color = vec4(0);

    //Retreive the minmax height from buffer and convert back to float (minor precision loss)
	float maxVertexHeight = minMax[1] / float(minMaxPrecisionFactor);
	float minVertexHeight = minMax[0] / float(minMaxPrecisionFactor);

	//Store Temperature In Red Channel
    //Find Height Difference in terms of the min and max vertex heights
	Color.r = max(floor(5.0 - ((verticies[index].Pos.y - minVertexHeight) / (maxVertexHeight - minVertexHeight)) * 5.0),0);

	//Store Humidity In Blue Channel Generated by Noise and then sampled as intergers
	Color.b = max(int(floor(fbm(verticies[index].Pos.xz)*6.0)),0);

    //Store the data into the given position within the biometexture
	imageStore(biomeTexture,id,Color);
}